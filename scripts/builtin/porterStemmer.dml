#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# ----------------------------------------------------------------------------
# Reference
# Porter stemmer in Java. The original paper is in
#   Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,
#   no. 3, pp 130-137,
# ----------------------------------------------------------------------------

# Builtin function that corrects corrupted frames of strings
# This algorithm operates on the assumption that most strings are correct
# and simply swaps strings that do not occur often with similar strings that 
# occur more often
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------
# NAME                              TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# strings                           String    ---      The nx1 input frame of corrupted strings
# frequency_threshold               Double    0.05     Strings that occur above this frequency level will not be corrected
# distance_threshold                integer   2        Max distance at which strings are considered similar
# decapitalize                      Boolean   TRUE     Decapitalize all strings before correction
# correct                           Boolean   TRUE     Correct strings or only report potential errors
# is_verbose                        Boolean   FALSE    Print debug information
#
#
# RETURN VALUES
# ----------------------------------------------------------------------------
# NAME     TYPE      DEFAULT  MEANING
# ----------------------------------------------------------------------------
# Y        Frame        -     Corrected nx1 output frame
# ----------------------------------------------------------------------------

words = frame(["caresses", "ponies", "cats", "matting", "milling", "meeting", "meetings"], rows=7, cols=1)
stemmed = frame("", rows=7, cols=1)
for(i in 1:nrow(words))
{
  word = as.scalar(words[i])
  word = step1a(word)
  word = step1b(word)
  word = step1c(word)
  word = step2(word)
  word = step3(word)
  word = step4(word)
  stemmed[i] = word
}

print("stemmed word "+toString(stemmed))


isCons = function(String letter)
return(Boolean isConst)
{
  isConst = TRUE
  if(letter == 'a' | letter == 'e' | letter == 'i' |
  letter == 'o' | letter == 'u')
    isConst = FALSE
}

isConsonant = function(String word, int i, integer len)
return(Boolean isConst)
{
  isConst = FALSE
  letter = map(as.frame(word), "x -> x.charAt("+i+")")
  idx = ifelse(i == 0, (len-1), (i-1))
  letter2 = map(as.frame(word), "x -> x.charAt("+idx+")")
  letter = as.scalar(letter)
  letter2 = as.scalar(letter2)
  print("letter 1: "+letter)
  print("letter 2: "+letter2)
  while(FALSE){}
  isCon = isCons(letter)
  if(isCon)
    isConst = ifelse(letter == 'y' & isCons(letter2), FALSE, TRUE)
}

doubleCons = function(String stem)
return(Boolean isCon)
{
  len = map(as.frame(stem), "s -> s.length()")
  len = as.integer(as.scalar(len))
  isCon = FALSE
  if (len >= 2) {
    isCon = (isConsonant(stem, (len-1), len) & isConsonant(stem, len-2, len))
  }     
}

containsVowel = function(String stem)
return(Boolean isTrue)
{
  res = map(as.frame(stem), "x -> UtilFunctions.containsVowels(x)")
  isTrue = as.scalar(res) == "true"
}

getForm = function(String word)
return (String formStr)
{
  form = list()
  formStr = ""
  len = as.integer(as.scalar(map(as.frame(word), "s -> s.length()")))
  for(i in 1:len)
  { 
    print("getForm: i: "+i)
    print("word: "+word+" len: "+len)
    isCon = isConsonant(word, (i-1), len)
    print(isCon+ " i "+i)
    if(isCon) 
    {
      if(i != 1) {
        prev = as.scalar(form[length(form)])
        print("form ")
        print(toString(form))
        print("prev "+prev)
        if(prev != 'C')
          form = append(form, 'C')
      }
      else
        form = append(form, 'C')
    }
    else 
    {
      if(i != 0) {
        prev = as.scalar(form[length(form)])
        if(prev != 'V')
          form = append(form, 'V')
      }
      else
        form = append(form, 'V')
    }
  }
  for(j in 1:length(form))
    formStr = formStr + as.scalar(form[j])
}

getM = function(String word)
return(Integer m){
  form = getForm(word)
  m = as.integer(as.scalar(map(as.frame(form), "x -> UtilFunctions.countVC(x)")))
}


cvc = function(String word)
return(Boolean isCVC)
{
  len = as.integer(as.scalar(map(as.frame(word), "s -> s.length()")))
  if(len >= 3) 
  {
    f = (len-3)
    s = (len-2)
    t = (len-1)
    third = as.scalar(map(as.frame(word), "s -> s.charAt("+t+")"))
    isConF = isConsonant(word, f, len)
    isConS = isConsonant(word, s, len)
    isConT = isConsonant(word, t, len)
    if(isConF & !(isConS) & isConT) {
      if((third != 'w') & (third != 'x') & (third != 'y'))
        isCVC = TRUE
      else
        isCVC = FALSE
    }
     else
      isCVC = FALSE
  }
  else
    isCVC = FALSE
}

replace = function(String orig, String rem, String rep)
return(String replaced)
{
  print("replacing: "+orig)
  result = as.scalar(map(as.frame(orig), "x -> x.indexOf(\""+rem+"\")"))
  base = as.scalar(map(as.frame(orig), "x -> x.substring(0 , "+result+")"))
  replaced = base + rep
}  

replaceM0 = function(String orig, String rem, String rep) 
return (String replaced){
  result = as.scalar(map(as.frame(orig), "x -> x.indexOf(\""+rem+"\")"))
  base = as.scalar(map(as.frame(orig), "x -> x.substring(0 , "+result+")"))
  m = getM(base) 
  if(m > 0)
    replaced = base + rep
  else  replaced =  orig
}

replaceM1 = function(String orig, String rem, String rep) 
return(String replaced){
  result = as.scalar(map(as.frame(orig), "x -> x.indexOf(\""+rem+"\")"))
  base = map(as.frame(orig), "x -> x.substring(0 , "+result+")")
  base = as.scalar(base)
  m = getM(base)
  if(m > 1)
    replaced = base + rep
  else  replaced =  orig
}



endsWith = function(String word, String suffix)
return(Boolean isTrue)
{
  res = map(as.frame(word), "x -> x.endsWith(\""+suffix+"\")")
  isTrue = as.scalar(res) == "true"
  }

step1a = function(String word)
return (String word)
{
  ew1 = endsWith(word, 'sses') 
  ew2 = endsWith(word, 'ies') 
  ew3 = endsWith(word, 'ss') 
  ew4 = endsWith(word, 's') 
  if(ew1)
    word = replace(word, 'sses', 'ss')
  else if(ew2)
    word = replace(word, 'ies', 'i')
  else if(ew3)
    word = replace(word, 'ss', 'ss')
  else if(ew4)
    word = replace(word, 's', '')
  print("step1: word after "+word)
}

step1b = function(String word)
return(String word)
{
  flag = FALSE
  len = as.integer(as.scalar(map(as.frame(word), "s -> s.length()")))
  ew = endsWith(word, 'eed')
  ew1 = endsWith(word, 'ed')
  ew2 = endsWith(word, 'ing')
  if(ew) {
    result = as.scalar(map(as.frame(word), "x -> x.indexOf(\"eed\")"))
    base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+result+")"))
    m = getM(base)
    if(m > 0)
    {  
      word = base
      word = word + 'ee'
    }
  }
  else if(ew1) {
    result = as.scalar(map(as.frame(word), "x -> x.indexOf(\"ed\")"))
    base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+result+")"))
    hasVowel = containsVowel(base)
    if(hasVowel)
    {
      word = base
      flag = TRUE
    }
  }
  else if(ew2)
  {
    result = as.scalar(map(as.frame(word), "x -> x.indexOf(\"ing\")"))
    base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+result+")"))
    print("step1b: ing "+base)
    hasVowel = containsVowel(base)
    print("hasVowel "+hasVowel)
    if(hasVowel) {
      word = base
      flag = TRUE
    }
  }
  # if(flag)
  # {
    # if(endsWith(word,'at') | endsWith(word,'bl') | endsWith(word,'iz'))
      # word = word + 'e'
    # else if(doubleCons(word) & !(endsWith(word, 'l')) & !(endsWith(word, 's')) & !(endsWith(word, 'z')))
      # word = as.scalar(map(as.frame(word), "x -> x.subString(0, "+(len-1)+")"))
    # else if(getM(word) == 1 & cvc(word))
      # word = word + 'e'
  # }
}


step1c = function(String word)
return(String word)
{
  ew = endsWith(word, 'y')
  base = ""
  if(ew)
  {
    result = as.scalar(map(as.frame(word), "x -> x.indexOf(\"y\")"))
    base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+result+")"))
  }
  hasVowel = containsVowel(base)
  if(hasVowel)
  {  
    word = base
    word = word + 'i'
  }
}

step2 = function(String word) 
return(String word)
{
  ending = frame("", rows = 26, cols = 2)
  ending[1, 1] = 'ational' ; ending[1, 2] = 'ate' ; 
  ending[2, 1] = 'tional' ; ending[2, 2] = 'tion' ; 
  ending[3, 1] = 'enci' ; ending[3, 2] = 'ence' ; 
  ending[4, 1] = 'anci' ; ending[4, 2] = 'ance' ; 
  ending[5, 1] = 'izer' ; ending[5, 2] = 'ize' ; 
  ending[6, 1] = 'abli' ; ending[6, 2] = 'able' ; 
  ending[7, 1] = 'alli' ; ending[7, 2] = 'al' ; 
  ending[8, 1] = 'entli' ; ending[8, 2] = 'ent' ; 
  ending[9, 1] = 'eli' ; ending[9, 2] = 'e' ; 
  ending[10, 1] = 'ousli' ; ending[10, 2] = 'ous' ; 
  ending[11, 1] = 'ization' ; ending[11, 2] = 'ize' ; 
  ending[12, 1] = 'ation' ; ending[12, 2] = 'ate' ; 
  ending[13, 1] = 'ator' ; ending[13, 2] = 'ate' ; 
  ending[14, 1] = 'alism' ; ending[14, 2] = 'al' ; 
  ending[15, 1] = 'iveness' ; ending[15, 2] = 'ive' ; 
  ending[16, 1] = 'fullness' ; ending[16, 2] = 'full' ; 
  ending[17, 1] = 'ousness' ; ending[17, 2] = 'ous' ; 
  ending[18, 1] = 'aliti' ; ending[18, 2] = 'al' ; 
  ending[19, 1] = 'iviti' ; ending[19, 2] = 'ive' ; 
  ending[20, 1] = 'biliti' ; ending[20, 2] = 'ble' ; 
  ending[21, 1] = 'icate' ; ending[21, 2] = 'ic' ; 
  ending[22, 1] = 'ative' ; ending[22, 2] = '' ; 
  ending[23, 1] = 'alize' ; ending[23, 2] = 'al' ; 
  ending[24, 1] = 'iciti' ; ending[24, 2] = 'ic' ; 
  ending[25, 1] = 'ful' ; ending[25, 2] = '' ; 
  ending[26, 1] = 'ness' ; ending[26, 2] = '' ; 
  found = FALSE
  i = 1
  while((i < nrow(ending)) & !(found))
  {
    wew = endsWith(word, as.scalar(ending[i, 1]))
    if(wew)
    {
      word = replaceM0(word, as.scalar(ending[i, 1]), as.scalar(ending[i, 2]))
      found = TRUE;
    }
    i = i + 1
  }
  
  # if(endswith(word, ))
    # word = replaceM0(word, 'ational', 'ate')
  # else if(endswith(word, 'tional'))
    # word = replaceM0(word, 'tional', 'tion')
  # else if(endsWith(word,'enci'))
    # word = replaceM0(word, 'enci', 'ence')
  # else if(endsWith(word,'anci'))
    # word = replaceM0(word, 'anci', 'ance')
  # else if(endsWith(word,'izer'))
    # word = replaceM0(word, 'izer', 'ize')
  # else if(endsWith(word,'abli'))
    # word = replaceM0(word, 'abli', 'able')
  # else if(endsWith(word,'alli'))
    # word = replaceM0(word, 'alli', 'al')
  # else if(endsWith(word,'entli'))
    # word = replaceM0(word, 'entli', 'ent')
  # else if(endsWith(word,'eli'))
    # word = replaceM0(word, 'eli', 'e')
  # else if(endsWith(word,'ousli'))
    # word = replaceM0(word, 'ousli', 'ous')
  # else if(endsWith(word,'ization'))
    # word = replaceM0(word, 'ization', 'ize')
  # else if(endsWith(word,'ation'))
    # word = replaceM0(word, 'ation', 'ate')
  # else if(endsWith(word,'ator'))
    # word = replaceM0(word, 'ator', 'ate')
  # else if(endsWith(word,'alism'))
    # word = replaceM0(word, 'alism', 'al')
  # else if(endsWith(word,'iveness'))
    # word = replaceM0(word, 'iveness', 'ive')
  # else if(endsWith(word,'fulness'))
    # word = replaceM0(word, 'fulness', 'ful')
  # else if(endsWith(word,'ousness'))
    # word = replaceM0(word, 'ousness', 'ous')
  # else if(endsWith(word,'aliti'))
    # word = replaceM0(word, 'aliti', 'al')
  # else if(endsWith(word,'iviti'))
    # word = replaceM0(word, 'iviti', 'ive')
  # else if(endsWith(word,'biliti'))
    # word = replaceM0(word, 'biliti', 'ble')
}
# step3 = function(String word)
# return(String word)
# {
  # if(endsWith(word,'icate'))
    # word = replaceM0(word, 'icate', 'ic')
  # else if( endsWith(word,'ative'))
    # word = replaceM0(word, 'ative', '')
  # else if( endsWith(word,'alize'))
    # word = replaceM0(word, 'alize', 'al')
  # else if( endsWith(word,'iciti'))
    # word = replaceM0(word, 'iciti', 'ic')
  # else if( endsWith(word,'ful'))
    # word = replaceM0(word, 'ful', '')
  # else if( endsWith(word,'ness'))
    # word = replaceM0(word, 'ness', '')

# }
step3 = function(String word)
return(String word)
{
  c1 = endsWith(word,'al')
  c2 = endsWith(word,'ance')
  c3 = endsWith(word,'ence')
  c4 = endsWith(word,'er')
  c5 = endsWith(word,'ic')
  c6 = endsWith(word,'able')
  c7 = endsWith(word,'ible')
  c8 = endsWith(word,'ant')
  c9 = endsWith(word,'ement')
  c10 = endsWith(word,'ment')
  c11 = endsWith(word,'ent')
  c12 = endsWith(word,'ou')
  c13 = endsWith(word,'ism')
  c14 = endsWith(word,'ate')
  c15 = endsWith(word,'iti')
  c16 = endsWith(word,'ous')
  c17 = endsWith(word,'ive')
  c18 = endsWith(word,'ize')
  c19 = endsWith(word,'ion')
  
  
  if(c1)
      word = replaceM1(word, 'al', '')
  else if(c2)
      word = replaceM1(word, 'ance', '')
  else if(c3)
      word = replaceM1(word, 'ence', '')
  else if(c4)
      word = replaceM1(word, 'er', '')
  else if(c5)
      word = replaceM1(word, 'ic', '')
  else if(c6)
      word = replaceM1(word, 'able', '')
  else if(c7)
      word = replaceM1(word, 'ible', '')
  else if(c8)
      word = replaceM1(word, 'ant', '')
  else if(c9)
      word = replaceM1(word, 'ement', '')
  else if(c10)
      word = replaceM1(word, 'ment', '')
  else if(c11)
      word = replaceM1(word, 'ent', '')
  else if(c12)
      word = replaceM1(word, 'ou', '')
  else if(c13)
      word = replaceM1(word, 'ism', '')
  else if(c14)
      word = replaceM1(word, 'ate', '')
  else if(c15)
      word = replaceM1(word, 'iti', '')
  else if(c16)
      word = replaceM1(word, 'ous', '')
  else if(c17)
      word = replaceM1(word, 'ive', '')
  else if(c18)
      word = replaceM1(word, 'ize', '')
  else if(c19)
  {
    result = as.scalar(map(as.frame(word), "x -> x.indexOf(\"ion\")"))
    base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+result+")"))
    m = getM(base)
    c1 = endsWith(base, 's')
    c2 = endsWith(base, 't')
    if((m > 1) & c1 | c2)
      word = base
    word = replaceM1(word, '', '')
  }
}

step4 = function(String word)
return(String word)
{
  len = as.integer(as.scalar(map(as.frame(word), "s -> s.length()")))
  len = len - 1
  base = as.scalar(map(as.frame(word), "x -> x.substring(0 , "+len+")"))
  m = getM(base)
  cond = endsWith(word,'e')
  isCVC = cvc(base)
  dc = doubleCons(word)
  ewl = endsWith(word, 'l')
  if(cond) {
    if(m > 1)
      word = base
    else if((m == 1) & !(isCVC))
      word = base
  }
  else if((m > 1) & dc & ewl)
    word = base
}

