#-------------------------------------------------------------
#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# change log
# 1. R constant R = 50
# 2. Do not remove the top pipeline from set

m_bandit = function(Matrix[Double] X_train, Matrix[Double] Y_train, Matrix[Double] X_val, Matrix[Double] Y_val, 
           Matrix[Double] mask, Frame[Unknown] schema, Frame[Unknown] lp, Frame[Unknown] primitives, 
           Frame[Unknown] param, Integer k = 3, Double testAccuracy = 0.8, Boolean isWeighted,  Boolean verbose = TRUE)
           
  return (Frame[Unknown] bestPipeline, Matrix[Double] bestHyperparams,  Matrix[Double] bestAccuracy ) 
{

  hparam = list()
  pipeline = list()
  # variable names follow publication where algorithm is introduced
  eta = 2  # the halving ratio is fixed
  R =  50 #(eta^k) + 1 # R is also fixed (eta^k) + 1
  s_max = floor(log(R,eta));
  B = (s_max + 1) * R;
  # if(s_max < k)
    # stop("unable to generate "+k+" pipelines. Please increase the resources or decrease k")
  
  for(s in s_max:0) {
    
    bracket_hp = list()
    bracket_pipel = list()
    
    n = ceil(floor(B/R/(s+1)) * eta^s);
    r = R * eta^(-s);
    configurations = get_physical_configurations(lp, n, primitives)
    
    if(verbose) {
      print("n "+n)
      print("R "+ R)
      print("s_max "+ s_max)
      print("B "+ B)
      print("n "+ n)
      print("r "+ r)
    }
    
    for( i in 0:s ) {
      # successive halving    
      n_i = as.integer(floor(n * eta^(-i)));
      r_i = as.integer(floor(r * eta^i));
      
      if(verbose) {
        print("no of configurations ------------------------"+n_i)
        print("no of resources ------------------------"+r_i)
        print("iteration  ------------------------"+i)
        while(FALSE){}
      }
      configurations = configurations[1:n_i, ]
      [a,b] = run_with_hyperparam(configurations, r_i, X_train, Y_train, X_val, Y_val, mask, schema, param, isWeighted, verbose)
      a = frameSort(a)
      b = order(target = b, by = 1, decreasing=TRUE, index.return=FALSE)
      rowIndex = ifelse(nrow(a) > k, k, nrow(a))
      bracket_pipel = append(bracket_pipel, a[1:rowIndex,])
      bracket_hp = append(bracket_hp, b[1:rowIndex, ])
    }
      print("inside brackets ")
      print(toString(bracket_pipel))
      print("------------------")
      print(toString(bracket_hp))
      while(FALSE){}
    print("print ho gaya")
    [bracket_bestPipeline, bracket_bestHyperparams] = extractTopK(bracket_pipel, bracket_hp, testAccuracy, k)
    pipeline = append(pipeline, bracket_bestPipeline)
    hparam = append(hparam, bracket_bestHyperparams)
  }
  print("after all brackets ")
  while(FALSE){}
  print(toString(pipeline))
  print("------------------")
  print(toString(hparam))
  while(FALSE){}
  [bestPipeline, bestHyperparams] = extractTopK(pipeline, hparam, testAccuracy, k)
  bestAccuracy = as.matrix(bestPipeline[, 1])
  bestPipeline = bestPipeline[,2:ncol(bestPipeline)]
  bestHyperparams = bestHyperparams[,2:ncol(bestHyperparams)]
  if(verbose) {
    print("best pipeline"+ toString(bestPipeline))
    print("best hyper-parameters \n"+ toString(bestHyperparams))
    print("best accuracy \n"+ toString(bestAccuracy))
    print("dirty accuracy "+testAccuracy)
  }
}


get_physical_configurations = function(Frame[String] logical, Scalar[int] n, Frame[Unknown] primitives)
  return(Frame[String] physical)
{
  # load the primitives
  physical = as.frame("NaN")
  outliers = primitives[,1]
  mvi = primitives[,2]
  ci = primitives[,3]
  dim = primitives[,4]
 
  operator = as.frame(matrix(0,nrow(outliers),1)) #combine all logical primitives
  for(j in 1:ncol(logical))
  {
 
    if(as.scalar(logical[1,j]) == "OTLR")
      operator = cbind(operator, outliers);
    else if(as.scalar(logical[1,j]) == "MVI")
      operator = cbind(operator, mvi);
    else if(as.scalar(logical[1,j]) == "CI")
      operator = cbind(operator, ci);
    else if(as.scalar(logical[1,j]) == "DIM")
      operator = cbind(operator, dim);  
  }
  opt = operator[,2:ncol(operator)] 
  
  idx = seq(1, ncol(opt))
  # get the indexes of columns for recode transformation
  index = vectorToCsv(idx)
  # recode logical pipelines for easy handling
  jspecR = "{ids:true, recode:["+index+"]}";
  [X, M] = transformencode(target=opt, spec=jspecR);
  X = replace(target= X, pattern = NaN, replacement = 0)
  paramLens = matrix(0, ncol(logical), 1);
  for( j in 1:ncol(logical)) {
    vect = removeEmpty(target = X[,j], margin = "rows");
    paramLens[j,1] = nrow(vect);
  }
   paramVals = matrix(0, ncol(logical), max(paramLens));
   for( j in 1:ncol(logical) ) {
    vect = removeEmpty(target = X[,j], margin = "rows");
    paramVals[j,1:nrow(vect)] = t(vect);
  }
  cumLens = rev(cumprod(rev(paramLens))/rev(paramLens));
  numConfigs = n;
  # Step 1) materialize hyper-parameter combinations 
  # (simplify debugging and compared to compute negligible)
  HP = matrix(0, numConfigs, ncol(logical));
  parfor( i in 1:nrow(HP) ) {
    for( j in 1:ncol(logical) ) {
      HP[i,j] = paramVals[j,as.scalar(((i-1)/cumLens[j,1])%%paramLens[j,1]+1)];
    }
  }
  
  physical = transformdecode(target=HP, spec=jspecR, meta=M);
  # print("all physical configurations "+toString(physical))
}

run_with_hyperparam = function(Frame[String] ph_pip, Integer r_i, Matrix[Double] X, Matrix[Double] Y, 
                      Matrix[Double] X_val, Matrix[Double] Y_val, Matrix[Double] mask, Frame[Unknown] schema, Frame[Unknown]  param, Boolean isWeighted, Boolean verbose)
                      
return (Frame[Unknown] output_operator, Matrix[Double] output_hyperparam)
{
  output_hyperparam = matrix(-1, 1, 1)
  output_operator = as.frame("")
  clone_X = X
  clone_x_val = X_val  
  clone_Y = Y
  clone_y_val = Y_val
  for(i in 1:nrow(ph_pip))
  {

    # execute configurations with r resources and keep the best
    for(r in 1:r_i)
    {
      tmp_hp = matrix(0, 1, 1)
      tmp_op = as.frame("")
      best_acc = as.double(0.0)
      hp = getHyperparam(ph_pip[i,], param)
      best_hp = hp
      [X, Y] = executePipeline(ph_pip[i], X, Y, mask, schema, hp, FALSE)
      while(FALSE){}
      [X_val, Y_val] = executePipeline(ph_pip[i], X_val, Y_val, mask, schema, hp, FALSE)
      while(FALSE){}
      accuracy = fclassify(X, Y, X_val, Y_val, isWeighted)
      # if(accuracy > best_acc) {
        best_acc = accuracy
        # best_hp = hp
      # }

    
    hp_vec = listToVector(best_hp, FALSE)
    tmp_hp = cbind(cbind(as.matrix(best_acc), hp_vec), tmp_hp) #TODO list to vector
    tmp_op = cbind(cbind(as.frame(best_acc), ph_pip[i]), tmp_op) #TODO list to vector
    if(as.scalar(output_hyperparam[1,1]) == -1 )
    {
      output_hyperparam = tmp_hp
      output_operator = tmp_op
    }
    else
    {
      if(ncol(tmp_hp) < ncol(output_hyperparam))
        tmp_hp = cbind(tmp_hp, matrix(0,1,ncol(output_hyperparam) - ncol(tmp_hp)))
      else if(ncol(tmp_hp) > ncol(output_hyperparam))
        output_hyperparam = cbind(output_hyperparam, matrix(0,nrow(output_hyperparam), ncol(tmp_hp) - ncol(output_hyperparam) ))
      
      output_hyperparam = rbind(output_hyperparam, tmp_hp)
      output_operator = rbind(output_operator, tmp_op)
    }
      X = clone_X
      X_val = clone_x_val
      Y = clone_Y
      Y_val = clone_y_val
    }

  }
  output_hyperparam = output_hyperparam[, 1:ncol(output_hyperparam) - 1]
  output_operator = output_operator[, 1:ncol(output_operator) - 1]

}


# getHyperparam = function(Frame[Unknown] pipeline, Frame[Unknown]  hpList)
# return (List[Unknown] paramList)
# {
  # # load the hyper-parameters values
  # paramList = list()
  # for(i in 1:ncol(pipeline)) {
    # op = as.scalar(pipeline[1,i])
    # hasParam = map(hpList[,1], "x->x.contains(\""+op+"\")")
    # m_hasParam = matrix(0, nrow(hasParam), 1)
    
    # for(h in 1:nrow(hasParam))
      # m_hasParam[h] = ifelse(as.scalar(hasParam[h,1]) == "true",1,0)
      
    # if(sum(m_hasParam) > 0) { 
      # index = m_hasParam * seq(1, nrow(m_hasParam))
      # index = as.scalar(removeEmpty(target = index, margin = "rows"))
      # d = as.integer(as.scalar(hpList[index, 2]))
      # p = 3
      # parameters =  matrix(0, 1, d)
      # if(d != 0)
      # {
        # for(j in 1:d) {
          # minVal = as.scalar(hpList[index, p]);
          # maxVal = as.scalar(hpList[index, p + 1]);
          # val = as.scalar(rand(rows=1, cols=1, min=minVal, max=maxVal, pdf="uniform" ));
          # parameters[1, j] = val;
          # p = p + 2; 
        # }
      # }
      
      # parameters = cbind(parameters, as.matrix(hpList[index, p]));
      # paramList = append(paramList, parameters)
    # }
    # else 
      # paramList = append(paramList, as.matrix(-1))
  # }
# }

getHyperparam = function(Frame[Unknown] pipeline, Frame[Unknown]  hpList)
return (List[Unknown] paramList)
{
  # load the hyper-parameters values
  paramList = list()
  for(i in 1:ncol(pipeline)) {
    op = as.scalar(pipeline[1,i])
    hasParam = map(hpList[,1], "x->x.contains(\""+op+"\")")
    m_hasParam = matrix(0, nrow(hasParam), 1)
    
    for(h in 1:nrow(hasParam))
      m_hasParam[h] = ifelse(as.scalar(hasParam[h,1]) == "true",1,0)
      
    if(sum(m_hasParam) > 0) { 
      index = m_hasParam * seq(1, nrow(m_hasParam))
      index = as.scalar(removeEmpty(target = index, margin = "rows"))
      d = as.integer(as.scalar(hpList[index, 2]))
      p = 3
      parameters =  matrix(0, 1, d)
      if(d != 0)
      {
        for(j in 1:d) {
          minVal = as.scalar(hpList[index, p]);
          maxVal = as.scalar(hpList[index, p + 1]);
          val = as.scalar(rand(rows=1, cols=1, min=minVal, max=maxVal, pdf="uniform" ));
          parameters[1, j] = val;
          p = p + 2; 
        }
      }
      
      parameters = cbind(parameters, as.matrix(hpList[index, p]));
      paramList = append(paramList, parameters)
    }
    else 
      paramList = append(paramList, as.matrix(-1))
  }
}





listToVector = function(List[Unknown] hp, Boolean verbose)
return (Matrix[Double] hp_vec)
{
  hp_vec = matrix(0, 1, 0)
  len = length(hp)
  for(k in 1:len) {
    mat = as.matrix(hp[k])
    if(sum(mat) != -1)
      hp_vec = cbind(hp_vec, as.matrix(ncol(mat)), mat)
    else hp_vec = cbind(hp_vec, as.matrix(-1))
  }
}


# fclassify = function(Matrix[Double] X, Matrix[Double] Y,  Matrix[Double] X_val, Matrix[Double] y_val)
# return (Double accuracy)
# {

  # if(max(Y) == min(Y)) {
    # print("Y contains only one class")
    # accuracy = 0
  # }
  # else 
  # { 
    # betas = multiLogReg(X=X, Y=Y, icpt=2, tol=1e-9, reg=0.00001, maxi=50, maxii=50, verbose=FALSE)
    # [prob, yhat, accuracy] = multiLogRegPredict(X_val, betas, y_val, FALSE)
  # }
# }
fclassify = function(Matrix[Double] X, Matrix[Double] Y,  Matrix[Double] X_val, Matrix[Double] y_val, Boolean isWeighted)
return (Double accuracy)
{



  if(max(Y) == min(Y)) {
    print("Y contains only one class")
    # tab = table(Y, 1)
    # print("dist in Y "+toString(tab))
    accuracy = 0
  }
  else 
  { 
    accuracyMatrix = crossV(rbind(X, X_val), rbind(Y, y_val), 10, isWeighted)
    acc = colMeans(accuracyMatrix)
    accuracy = as.scalar(acc[1,1])
    print("validation accuracy "+accuracy)
  }
}

crossV = function(Matrix[double] X, Matrix[double] y, Integer k, Boolean isWeighted) 
return (Matrix[Double] accuracyMatrix)
{

  #create empty lists
  dataset_X = list(); #empty list
  dataset_y = list();
  fs = ceil(nrow(X)/k);
  off = fs - 1;
  #divide X, y into lists of k matrices
  for (i in seq(1, k)) {
    dataset_X = append(dataset_X, X[i*fs-off : min(i*fs, nrow(X)),]);
    dataset_y = append(dataset_y, y[i*fs-off : min(i*fs, nrow(y)),]);
  }

  accuracyMatrix = matrix(0, k, 2)

  #keep one fold for testing in each iteration
  for (i in seq(1, k)) {
    [tmpX, testX] = remove(dataset_X, i);
    [tmpy, testy] = remove(dataset_y, i);
    trainX = rbind(tmpX);
    trainy = rbind(tmpy);
    trainX = trainX[,1:ncol(X)] # TODO improve list size propagation
    testX = as.matrix(testX)
    testy = as.matrix(testy)
    beta = multiLogReg(X=trainX, Y=trainy, icpt=2, reg=0.00001, tol=1e-9, maxi=50, maxii= 50, verbose=FALSE);
    [prob, yhat, a] = multiLogRegPredict(testX, beta, testy, FALSE)
    
    accuracy = accuracy_metric(testy, yhat, isWeighted)

    accuracyMatrix[i, 1] = accuracy * 100

    while(FALSE){}
  }
}

extractTopK = function(List[Unknown] pipeline, List[Unknown] hyperparam, Double testAccuracy, Integer k)
return (Frame[Unknown] bestPipeline, Matrix[Double] bestHyperparams)
{
  len = length(pipeline)
  print("length "+len)
  # process the pipelines
  bestPipeline = as.frame(pipeline[1])
  pipelineLength = ncol(bestPipeline)
  if(len > 1)
  {
    for(i in 2:length(pipeline))
    {
      right = as.frame(pipeline[i, 1:pipelineLength])
      bestPipeline = rbind(bestPipeline, right )

    }
  }

  # process the hyper-parameters
  pipLen = matrix(0, length(hyperparam), 1)
  pipWidth = matrix(0, length(hyperparam), 1)
  for(i in 1:length(hyperparam))
  {
    mat = as.matrix(hyperparam[i])
    pipLen[i] = ncol(mat)
    pipWidth[i] = nrow(mat)
  }
  rowLen = cumsum(pipWidth)
  bestHyperparams = matrix(0, max(rowLen), max(pipLen))
  
  start = 1
  for(i in 1: length(hyperparam))
  { 
    matSep = as.scalar(rowLen[i])
    vect = as.matrix(hyperparam[i])
    bestHyperparams[start:matSep, 1:ncol(vect)] = vect 
    start = matSep + 1
  }

  mask = (bestHyperparams[, 1] < testAccuracy) == 0
  bestPipeline = frameRmEmpty(bestPipeline, mask)
  bestHyperparams = removeEmpty(target = bestHyperparams, margin = "rows", select = mask)
  
  bestPipeline = frameSort(bestPipeline)
  bestHyperparams = order(target = bestHyperparams, by = 1, decreasing=TRUE, index.return=FALSE)
  rowIndex = ifelse(nrow(bestPipeline) > k, k, nrow(bestPipeline))

  bestPipeline = bestPipeline[1:rowIndex,]
  bestHyperparams = bestHyperparams[1:rowIndex,]

}

frameRmEmpty = function(Frame[Unknown] frameblock, Matrix[Double] selectMatrix)
return (Frame[Unknown] frameblock)
{
  idx = seq(1, ncol(frameblock))
  # get the indexes of columns for recode transformation
  index = vectorToCsv(idx)
  # recode logical pipelines for easy handling
  jspecR = "{ids:true, recode:["+index+"]}";
  [X, M] = transformencode(target=frameblock, spec=jspecR);
  X = removeEmpty(target = X, margin = "rows", select = selectMatrix)
  frameblock = transformdecode(target = X, spec = jspecR, meta = M)
}

SMOTE  = function(Matrix[Double] X, Matrix[Double] Y, Boolean verbose)
return (Matrix[Double] X, Matrix[Double] Y)
{
  while(FALSE){}
  XY = order(target = cbind(Y, X),  by = 1, decreasing=FALSE, index.return=FALSE)
  # get the class count 
  classes = table(Y, 1)
  
  start_class = 1
  end_class = 0
  k = table(Y, 1)
  getMax = max(k)
  maxKIndex = as.scalar(rowIndexMax(t(k)))
  print("max index: "+maxKIndex)
  while(FALSE){}
  outSet = matrix(0, 0, ncol(XY))
  
  for(i in 1: nrow(k))
  {
   
    if(!(i == maxKIndex))
    {
      end_class = end_class + as.scalar(classes[i])
      class_t = XY[start_class:end_class, ]
      remainingRatio = getMax - nrow(class_t)
      synthesized = smote(class_t, remainingRatio, 1, FALSE)
      outSet = rbind(outSet, synthesized)
      start_class = end_class + 1
      if(verbose)
      {
        print("max value: "+getMax)
        print("values of i: "+i)
        print("remaining ratio: "+remainingRatio)
        print("synthesized \n"+toString(synthesized))
      
      }
    }
  }
  
  XY = rbind(XY, synthesized)
  Y = XY[, 1]
  X = XY[, 2:ncol(XY)]
}


