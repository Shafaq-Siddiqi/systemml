#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

X = read($1, data_type="frame", format="csv", header=TRUE, naStrings= ["NA", "null"," ","NaN", "nan", "", "?"]);
meta = read($2, data_type="frame", format="csv", header=FALSE);
primitives = read($3, data_type = "frame", format="csv", header= TRUE)
param = read($4, data_type = "frame", format="csv", header= FALSE)
[result, res] = startCleaning(X, "classification",  meta, primitives, param, 5, TRUE) 
output = as.logical(as.scalar(res[1,1] < res[1,2]))
write(output, $5, format = "text")


startCleaning = function(Frame[Unknown] F, String targetApplication = "classification", Frame[Unknown] metaInfo, Frame[Unknown] primitives, 
                Frame[Unknown] param, Integer k, Boolean verbose = FALSE)
return (Frame[Unknown] result, Matrix[Double] res)
{
  res = as.matrix(0)
  result = as.frame(0)
  if(nrow(metaInfo) < 3)
    stop("incomplete meta info")
    
  # initialize variables
  eX = as.matrix(0)
  eY = as.matrix(0)
  
  
  
  getSchema = metaInfo[1, 2:ncol(metaInfo)]
  getMask = as.matrix(metaInfo[2, 2:ncol(metaInfo)])
  
  # validate schema 
  X = dropInvalidType(F, getSchema)

  if(sum(getMask) > 0 )
  {
    idx  = getMask * t(seq(1, ncol(X)))
    idx = removeEmpty(target = idx, margin = "cols")
    index = vectorToCsv(idx)
    jspecR = "{ids:true, recode:["+index+"]}"
    [eX, X_meta] = transformencode(target=X, spec=jspecR);
    
  } else {
    eX = as.matrix(X)
  }

  eY = eX[, ncol(X)]
  eX = eX[, 1:ncol(X) - 1]
    
  if(min(eY) == 0)
    eY = eY + 1 # add one to class labels so that the min label is greater then zero
    
  getMask = getMask[, 1:ncol(getMask) - 1] # strip the mask of class label

  [eX, eY] = doSample(eX, eY, 0.6)

  
  s = round(nrow(eX) * 0.7)  
  X_train = eX[1:s, ]
  y_train = eY[1:s, ]
 
  X_test = eX[s+1:nrow(eX), ]
  y_test = eY[s+1:nrow(eX), ]

  
  # TODO do it automatically
  logical = generateLogical(eX, eY) 
  # Generate logical Pipeline
  logical = as.frame("MVI")
  logical = cbind(logical, as.frame("OTLR"))
  logical = cbind(logical, as.frame("DIM"))
  logical = cbind(logical, as.frame("CI"))

  
  pip = as.frame("")
  hp = as.matrix(0)
  acc = as.matrix(0)

  [pip, hp, acc] = bandit(X_train, y_train, X_test, y_test, getMask, logical, primitives, param, k, TRUE);
  # print("output pip "+toString(pip))
  
  # reshuffle the dataset again for testing via permutation matrix
  permutation_matrix = table(seq(1, nrow(eX)), sample(nrow(eX), nrow(eX)))

  eX = permutation_matrix %*% eX
  eY = permutation_matrix %*% eY
  

  X_train = eX[1:s, ]
  y_train = eY[1:s, ]

  X_test = eX[s+1:nrow(eX), ]
  y_test = eY[s+1:nrow(eX), ]
  
  # hp = matrix("-1.000 4.000 4.234 1 76.328 -1.000 3.000 11.828 0.133 -1.000 2.000 0.659 1.000 0.000 0.000", rows = 1, cols = 15)
  
  # op1 = as.frame("imputeByMean")
  # op2 = cbind(op1, as.frame("outlierBySd"))
  # op3 = cbind(op2, as.frame("pca"))
  # pip = cbind(op3, as.frame("abstain"))
  res = testBestPipeline(pip, hp, X_train, y_train, X_test, y_test, getMask)
  

  
  
  
  _hp = cbind(matrix(NaN, nrow(hp), 1), hp)
  # _acc = cbind(matrix(NaN, nrow(hp), 1), acc)
  result = cbind(pip, as.frame(_hp))
  result = cbind(result, as.frame(acc))
}

testBestPipeline = function(Frame[Unknown] pip, Matrix[Double] hp, Matrix[Double] X_train, Matrix[Double] y_train, Matrix[Double] X_test, Matrix[Double] y_test, Matrix[Double] cmask)
return (Matrix[Double] result){
  ls = list();
  i = 1
  # construct the parameter list for best hyper-parameters
  while(i <= ncol(hp))
  {
    if(as.scalar(hp[1, i]) == -1) 
      ls = append(ls, as.matrix(-1)) 
    else if(as.scalar(hp[1, i]) > 0)
    {
      end = as.integer(i+as.scalar(hp[1,i]))
      mat = hp[1, i+1:end]
      i = end 
      ls = append(ls, mat)
    }
    i = i + 1
  }
  clone_X = X_train
  X_train = replace(target = X_train, pattern = NaN, replacement = 0)

  # classify without cleaning
  betas = multiLogReg(X=X_train, Y=y_train, icpt=2, tol=1e-9, reg=0.00001, maxi=100, maxii=0, verbose=FALSE)
  [d_prob, d_yhat, d_accuracy] = multiLogRegPredict(X_test, betas, y_test, FALSE)
  
  print("accuracy of test dirty  "+d_accuracy)

  X_train = clone_X
  # clean using best pipeline
  [X_train_clean, Y_train_clean] = executePipeline(pip[1,], X_train, y_train, cmask, ls, TRUE)
  print("here")
  while(FALSE){}
  [X_test_clean, Y_test_clean] = executePipeline(pip[1,], X_test, y_test, cmask, ls, FALSE)

  # classify after cleaning
  betas = multiLogReg(X=X_train_clean, Y=Y_train_clean, icpt=2, tol=1e-9, reg=0.00001, maxi=100, maxii=0, verbose=FALSE)
  [c_prob, c_yhat, c_accuracy] = multiLogRegPredict(X_test_clean, betas, Y_test_clean, FALSE)
  
  print("accuracy of test clean "+c_accuracy)

  result = cbind(as.matrix(d_accuracy), as.matrix(c_accuracy))
}

doSample = function(Matrix[Double] eX, Matrix[Double] eY, Double ratio)
return (Matrix[Double] eX, Matrix[Double] eY)
{
  # reshuffle the dataset via permutation matrix
  permutation_matrix = table(seq(1, nrow(eX)), sample(nrow(eX), nrow(eX)))
  eX = permutation_matrix %*% eX
  eY = permutation_matrix %*% eY
  
  # choose a sample  
  if(nrow(eX) > 10000)
  {
    s = round(nrow(eX) * ratio)
    eX = eX[1:s, ]
    eY = eY[1:s, ]
  }

}

generateLogical = function(Matrix[Double] X, Matrix[Double] Y)
{
  logical = as.frame("")
  # get the stats
  no_of_mv = sum(is.na(X))
  X = replace(target= X, pattern = NaN, replacement = 0)
  colMin = colMins(X)
  colMax = colMaxs(X)
  colMean = colMeans(X)
  colSd = colSds(X)
  count3sdplus = sum(X > (colMean + 3*colSd )) 
  count3sdminus = sum(X < (colMean - 3*colSd )) 
  outliers = count3sdplus + count3sdminus
  ctab = table(Y, 1)
  minCatPer = min(ctab) / nrow(ctab)
  maxCat = max(ctab) / nrow(ctab)
  
  mv_to_data_ratio = no_of_mv/(nrow(X) * ncol(X))
  out_to_data_ratio = outliers/ (nrow(X) * ncol(X))
  
  if(mv_to_data_ratio > 0.1)
    logical = cbind(logical, as.frame("MVI"))
  if(out_to_data_ratio > 0.1)
    logical = cbind(logical, as.frame("OTLR"))
  if((maxCat - minCatPer) > 0.3)
    logical = cbind(logical, as.frame("CI"))
  

}

